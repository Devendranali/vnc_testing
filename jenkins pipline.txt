git restore --staged filename
git rm --cached filename
--------------------------------------------------------------------------------------------------
FOR DOCKER STAGE :PIPELINE
--------------------------------------------------------------------------------------------------
pipeline {
    agent any  // This runs the pipeline on any available agent (Jenkins node)
    environment {
        DOCKER_IMAGE_NAME = 'solar_system'  // Docker image name (replace accordingly)
        DOCKER_IMAGE_TAG = '1'  // Docker image tag
    }

    stages {
        stage('Checkout') {
            steps {
                // Checkout the main branch from the repository
                git branch: 'main', url: 'https://github.com/vanthiyadhevan/solar-system-gitea-jenkins-advanced.git'
            }
        }
        
        stage('Install Dependencies') {
            steps {
                // Install dependencies using npm (Node.js project)
                sh 'npm install --no-audit'
            }
        }

        stage('Dependency Check') {
            steps {
                // Run a dependency check using npm audit
                sh 'npm audit fix --force'
            }
        }

        stage('Docker Build') {
            steps {
                script {
                    // Build Docker image
                    sh '''
                        docker build -t ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} .
                    '''
                }
            }
        }
    }
}






----------------------------------------------------------------------------------------------------------------------

For SONARQUBE: PIPELINE
----------------------------------------------------------------------------------------------------------------------
pipeline {
    agent any
    environment {
        scannerHome = tool 'SonarQube'
    }
    stages {
        stage('Checkout') {
            steps {
                git branch: 'master', url: 'https://github.com/Devendranali/one.git'
            }
        }
        stage('Maven Build') {
            steps {
                sh 'mvn -v'
                sh 'mvn clean install'
            }
        }
        stage('Run SonarQube') {
            steps {
                withSonarQubeEnv(credentialsId: 'Sonar-token', installationName: 'Sonar-Qube') {
                    sh """
                    ${scannerHome}/bin/sonar-scanner \
                        -Dsonar.projectKey=vnc-1 \
                        -Dsonar.projectName="vnc" \
                        -Dsonar.projectVersion=1.0 \
                        -Dsonar.sources=src
                    """
                }
            }
        }
    }
}



*******************************************************************java**************
FOR DOCKER STAGE CLEAN UP ALL AND LATEST UPDATED : PIPELINE
*************************************************************************************

pipeline {
    agent any 
    stages {
        stage (CLEANUP){
            steps {
	cleanWs()
             }
        }
        stage (CHECKOUT) {
            steps {
                git branch: 'master', url: 'https://github.com/Devendranali/one.git'
            }
        }
        stage (MAVEN) {
            steps {
                sh 'mvn clean install -Dskiptests'
            }
        }
        stage (TEST) {
            steps {
                sh 'mvn test'
            }
        }
        stage (CODECOVERAGE) {
            steps {
                sh 'mvn checkstyle:checkstyle'
            }
        }
        stage('Stop and Remove Containers') {
            steps {
                script {
                    // Stop and remove any running containers
                    sh 'docker stop $(docker ps -q) || true'  // Stop all running containers
                    sh 'docker rm -f $(docker ps -a -q) || true'  // Remove all containers
                }
            }
        }
        stage (DOCKER) {
            steps {
                sh 'docker rmi $(docker images -f "dangling=true" -q) || true'
                sh 'docker rmi -f $(docker images -q) || true'
                sh 'docker build -t one:1 .'
            }
        }
        stage (CONTAINER) {
            steps {
                sh 'docker rm -f myapp || true'
                sh 'docker run -itd --name myapp -p 8081:8080 one:1'
            }
        }
    }
}



`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````

LINKS:::

`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````

deploying the application in another ec2 server --k3s --

k3s link::   curl -sfL https://get.k3s.io | INSTALL_K3S_SKIP_SELINUX_RPM=true sh -
	sudo ln -s /usr/local/bin/kubectl /usr/bin/kubectl
	sudo chmod 644 /etc/rancher/k3s/k3s.yaml
	kubectl get nodes

kubectl link::  curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x ./kubectl
sudo mv ./kubectl /usr/local/bin/kubectl

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


FOR PUSHING IMAGE TO AWS ECR REPO AND DEPLOYED TO K3S IN ANOTHER EC2::  WORKING - PIPELINE


AWS CLI:  --> INSTALL 
		# 1. Download the installer
		curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
		unzip awscliv2.zip
		sudo ./aws/install

	  --> AFTER CREATE AWS ECR REPO USING CLI
		aws ecr create-repository --repository-name one --region us-east-1
	--> ATTACH THE ROLE TO THE JENKINS INSTANCE TO CONNECT WITH AWS ECR TO PUSH 		      IMAGE ARE PULL USE -- POLICY -- AMAZONEC2CONTAINERREGISTRYFULLACCESS.
	--> STORE AWS ECR URI IN JENKINS CREADENTAILS AND USE IN PIPELINE TO SECURE.
	--> CONFIGURE SSH AGENT PLUGIN  in jenkins AND CREDENTIALS OF K3S SERVER 
	--> INSTALL K3S AND ADD ROLE TO PULL THE IMAGE FROM ECR for k3s server 
		 POLICY --   AMAZONEC2CONTAINERREGISTRYREADONLYACCESS.
	
--> main thing is k3s is not access to pull the image with role and policy also ,,, so we need to create secret in k3s 	server to pull the image from aws-ecr otherwise we end up with crashpullbackoff error,  (only k3s not k8s.)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


pipeline {
    agent any
    environment {
        AWS_REGION = 'us-east-1'
        IMAGE_TAG = 'latest'
    }
    stages {
        stage ('CHECKOUT') {
            steps {
                git branch: 'master', url: 'https://github.com/Devendranali/one.git'
            }
        }

        stage ('MAVEN') {
            steps {
                sh 'mvn clean install -DskipTests'
            }
        }

        stage ('TEST') {
            steps {
                sh 'mvn test'
            }
        }

        stage('JACOCO REPORT') {
            steps {
                sh 'mvn jacoco:report'
                publishHTML(target: [
                    reportDir: 'target/site/jacoco',
                    reportFiles: 'index.html',
                    reportName: 'JaCoCo Code Coverage',
                    allowMissing: true,
                    alwaysLinkToLastBuild: true,
                    keepAll: true
                ])
            }
        }

        stage ('CODECOVERAGE') {
            steps {
                sh 'mvn checkstyle:checkstyle'
            }
        }

        stage ('DEPENDENCY CHECK') {
            steps {
                sh 'mvn org.owasp:dependency-check-maven:check'
            }
        }

        stage ('Stop and Remove Containers') {
            steps {
                script {
                    sh 'docker stop $(docker ps -q) || true'
                    sh 'docker rm -f $(docker ps -a -q) || true'
                }
            }
        }

        stage ('DOCKER BUILD') {
            steps {
                sh 'docker rmi $(docker images -f "dangling=true" -q) || true'
                sh 'docker rmi -f $(docker images -q) || true'
                sh 'docker build -t one:1 .'
            }
        }

        stage ('TRIVY SCAN') {
            steps {
                script {
                    sh 'trivy image --exit-code 1 --severity HIGH,CRITICAL one:1 || true'
                }
            }
        }

        stage ('ECR LOGIN AND PUSH') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'ecr-uri', variable: 'ECR_REPO')]) {
                        sh """
                            aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO}
                            docker tag one:1 ${ECR_REPO}:${IMAGE_TAG}
                            docker push ${ECR_REPO}:${IMAGE_TAG}
                        """
                    }
                }
            }
        }

        stage ('CONTAINER') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'ecr-uri', variable: 'ECR_REPO')]) {
                        sh """
                            docker rm -f myapp || true
                            docker run -itd --name myapp -p 8081:8080 ${ECR_REPO}:${IMAGE_TAG}
                        """
                    }
                }
            }
        }

        stage ('Deploy to K3s') {
            steps {
                sshagent(['jenkins-ssh-key']) {
                    withCredentials([string(credentialsId: 'ecr-uri', variable: 'ECR_REPO')]) {
                        sh """
                            sed 's|__ECR_IMAGE__|${ECR_REPO}:${IMAGE_TAG}|' k8s/k8s-deployment.yaml > k8s/k8s-deployment-final.yaml
                            scp -o StrictHostKeyChecking=no k8s/k8s-deployment-final.yaml ec2-user@54.163.209.189:/tmp/
                            scp -o StrictHostKeyChecking=no k8s/service.yaml ec2-user@54.163.209.189:/tmp/
                            ssh -o StrictHostKeyChecking=no ec2-user@54.163.209.189 'kubectl apply -f /tmp/k8s-deployment-final.yaml && kubectl apply -f /tmp/service.yaml'
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            junit 'target/surefire-reports/*.xml'
            publishHTML(target: [
                reportDir: 'target/dependency-check-report',
                reportFiles: 'dependency-check-report.html',
                reportName: 'Dependency Check Report',
                allowMissing: true
            ])
        }
    }
}



________________________________________________________________________________________

SAMPLE JENKINS TASK BY CHATGPT :


pipeline {
    agent any
    tools {
        jdk 'jdk'
        maven 'maven'
    }
    environment {
        git_repo = 'github.devendra.one'
    }
    parameters {
        string(name: 'branch_name', defaultValue: 'main', description: 'Branch to pull from GitHub')
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Git Checkout') {
            steps {
                git branch: "${params.branch_name}", url: "${git_repo}"
            }
        }
        stage('Maven Build') {
            steps {
                sh 'mvn clean install -DskipTests'
            }
        }
    }
}




---------------------------------------------------------------------------------------------------------------------------------------------------
Comparision of Nacl and Security Group::
--------------------------------------------------------------------------------------------------------------------------------------------------


Feature	Security Group	NACL

Level	Instance level (ENI)	Subnet level
Stateful	✅ Yes	❌ No
Default Behavior	All inbound denied, all outbound allowed	All inbound/outbound denied
Rules	Only "Allow" rules	Allow and Deny rules
Use Case	Protect EC2 or RDS instances	Control traffic across subnets
Applied To	ENIs, EC2s	Entire Subnet

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
web-application:

A web application is a software program that runs on a web server and is accessed through a web browser. Unlike desktop applications that are installed on a specific machine, web applications can be used from anywhere through the internet.
For example, applications like Gmail, Facebook, or online shopping sites like Amazon are web applications.


overview:

In this project, I was responsible for building and automating cloud infrastructure for a web application using AWS. We used Terraform to create and manage resources like VPC, subnets, route tables, EC2 instances, and S3 buckets, following Infrastructure as Code principles.

For application deployment, I set up Jenkins pipelines that handled automated builds, testing, and deployment. This allowed us to implement a full CI/CD pipeline, which reduced manual effort and improved reliability.

The application itself was Dockerized, so we used Docker to package and deploy it across environments consistently. We also stored our container images in Amazon ECR.

For monitoring, I configured Prometheus to collect performance metrics and Grafana to visualize them, which helped us monitor application health and system performance in real-time.

My key responsibilities included maintaining CI/CD pipelines, containerizing the application, managing deployments, and setting up effective monitoring solutions. The entire infrastructure was designed to be scalable, repeatable, and easy to maintain.









